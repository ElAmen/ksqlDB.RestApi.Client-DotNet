#!markdown

### Install the ksqlDB.RestApi.Client package
Install the package with NUGET package manager:
```
Install-Package ksqlDB.RestApi.Client
```

#!csharp

#r "nuget:ksqlDb.RestApi.Client, 1.3.0-rc.1"

#!markdown

# Run ksqldb in Docker

Run **ksqldb** in a docker container (this step may take a few minutes). The following code snippet clones the **ksqlDB.RestApi.Client-DotNet** repository in order to download the docker compose yaml file.
The containerized environment requires a running **Docker engine**. You can download and install **Docker Desktop** from [here](https://www.docker.com/products/docker-desktop).

Clone the repository:

#!pwsh

git clone https://github.com/tomasfabian/ksqlDB.RestApi.Client-DotNet.git c:\ksqlDB-DotNet

#!markdown

The result of the bellow commands should be an instance of zookeeper, kafka broker and ksqldb server.
The content of the docker compose file can be checked [here](https://github.com/tomasfabian/ksqlDB.RestApi.Client-DotNet/blob/main/Samples/Notebooks/docker-compose.yml).

#!pwsh

cd c:\ksqlDB-DotNet\Samples\Notebooks\

docker-compose up -d

#!markdown

# Insert some values

Prepare the domain model:

#!csharp

public record Tweet
{
  public int Id { get; init; }

  public string Message { get; init; }

  public string Author { get; init; }
}

#!markdown

**KSqlDbRestApiClient** class is used to execute SQL statements via the Rest API such as inserting records into streams and creating tables, types, etc. or executing admin operations such as listing streams.

Create a ksqldb stream in the following way:

#!csharp

using ksqlDB.RestApi.Client.KSql.RestApi.Http;
using ksqlDB.RestApi.Client.KSql.RestApi.Statements;
using ksqlDB.RestApi.Client.KSql.RestApi;
using System;

EntityCreationMetadata metadata = new()
{
  KafkaTopic = nameof(Tweet),
  Partitions = 1,
  Replicas = 1
};

var ksqlDbUrl = @"http:\\localhost:8088";

var ksqlDbUri = new Uri(ksqlDbUrl);
var httpClientFactory = new HttpClientFactory(ksqlDbUri);
var restApiClient = new KSqlDbRestApiClient(httpClientFactory);
      
var httpResponseMessage = await restApiClient.CreateOrReplaceStreamAsync<Tweet>(metadata);

Console.WriteLine(httpResponseMessage);

#!markdown

Insert some values to the prepared ksqlb stream named `Tweets`. The pluralized name is inferred from the Tweet class name. 
> Run the code.
>
> Then try inserting your own messages.

#!csharp

var responseMessage = await restApiClient
  .InsertIntoAsync(new Tweet { Id = 1, Message = "The answer is 42" });

responseMessage = await restApiClient
  .InsertIntoAsync(new Tweet { Id = 2, Message = "ksqlDB rulez!" });

#!markdown

# Create a query

**KSqlDBContext**'s primary responsibilities are to interact with your ksqldb with LINQ queries which are converted to KSQL, materializing raw data into your POCOs and persisting data into streams or tables.
`CreateQueryStream<TEnity>` is the entry point for composing LINQ queries.
Lets create a ksqldb context by providing it an url:

#!csharp

using ksqlDB.RestApi.Client.KSql.Query.Context;

var context = new KSqlDBContext(ksqlDbUrl);

#!markdown

Now you can subscribe to the underlying stream of events created in the previous step. The following compile time safe query filters the messages server side based on the provided predicate. In our contrived example the messages cannot be equal to `Hello world` or the Id must be equal to 1. 

`WithOffsetResetPolicy` is used to receive messages from the beginning of the log.

The `Take` operator instructs the ksqldb query engine to Limit the number of requested messages to 2. 

`Select` is used to project the resulting shape of the messages. In our case we've excluded the Author field.


And finally we are ready to start a new subscription. The `Subscribe` method has 3 arguments: onNext, onError and onCompleted. Semantics of the subscription are that you can receive 0-N values. The termination of the stream is indicated with an exception message in case of some error or by calling the onCompleted lambda which allows you to react to successfully finished subscriptions. 
After the completion of the query no more values will be received.

#!csharp

using ksqlDB.RestApi.Client.KSql.Linq;
using ksqlDB.RestApi.Client.KSql.Query.Options;
using System.Threading;

var semaphoreSlim = new SemaphoreSlim(0, 1);

var subscription = context.CreateQueryStream<Tweet>()
  .WithOffsetResetPolicy(AutoOffsetReset.Earliest)
  .Where(p => p.Message != "Hello world" || p.Id == 1)
  .Select(l => new { l.Message, l.Id })
  .Take(2)
  .Subscribe(onNext: tweetMessage =>
  {
    Console.WriteLine($"{nameof(Tweet)}: {tweetMessage.Id} - {tweetMessage.Message}");
  }, 
  onError: error => { 
    Console.WriteLine($"Exception: {error.Message}"); 
    
    semaphoreSlim.Release();
  },
  onCompleted: () => {
    Console.WriteLine("Completed");
    
    semaphoreSlim.Release();
  });

  await semaphoreSlim.WaitAsync();
  
  using(subscription) {}

#!markdown

You can also insert some values with the help of the ksqldb context:

#!csharp

var tweet3 = new Tweet { Id = 3, Message = "Hello world" };

context.Add(tweet3);

var tweet4 = new Tweet { Id = 4, Message = "Message 4" };

context.Add(tweet4);

var saveResponse = await context.SaveChangesAsync();

#!markdown

# Clean up

Dispose the context when you finished your work with it:

#!csharp

await context.DisposeAsync();

#!markdown

Stop the containers:

#!pwsh

docker-compose down
